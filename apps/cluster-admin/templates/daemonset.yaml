apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: cluster-admin
spec:
  selector:
    matchLabels:
      name: ssh-authorized-keys
  template:
    metadata:
      labels:
        name: ssh-authorized-keys
    spec:
      priorityClassName: system-node-critical
      tolerations:
        - operator: Exists
          effect: NoSchedule
        - key: CriticalAddonsOnly
          operator: Exists
        - operator: Exists
          effect: NoExecute
      initContainers:
        - name: ssh-authorized-keys
          # Pulled Dec 12, 2022
          image: python:3.8@sha256:7c5b3ec91b7e4131dead176d824ddf317e6c19fe1ae38c54ec0ae6038908dd18
          command:
            - python3
            - -c
            - |
              import os
              with open('/hostssh/authorized_keys', 'r') as f:
                authorized_keys = f.read()
              for k, v in os.environ.items():
                if k.startswith('SSHKEY_'):
                  k = k.replace('SSHKEY_', '')
                  if v not in authorized_keys:
                    with open('/hostssh/authorized_keys', 'a') as f:
                      f.write(f"\n\n# {k}\n{v}\n")
                    print(f'Added {k} to authorized_keys')
          envFrom:
            - configMapRef:
                name: ssh-authorized-keys
          volumeMounts:
            - name: hostssh
              mountPath: /hostssh
        - name: firewall
          # Built from docker/certbot on Dec 11, 2022
          # We use this image because it contains the dependencies we need
          image: ghcr.io/kamatera/kamateratoolbox-iac-certbot:8433ac3d1ec7ee901afb3a8894d8a251d5a409dc
          command:
            - bash
            - -c
            - |
              FORCE_RELOAD_DAEMONSET=no
              if ! kubectl get -n cluster-admin configmap allowed-ips -o json | grep "ALLOWED_IP" | grep '"'${HOST_IP}'"'; then
                echo "Adding ${HOST_IP} to allowed-ips configmap"
                kubectl patch configmap/allowed-ips -n cluster-admin --type merge \
                  -p '{"data":{"'ALLOWED_IP_${HOST_IP}'":"'${HOST_IP}'"}}'
                FORCE_RELOAD_DAEMONSET=yes
              fi
              cp /opt/secret/sshapprivatekey /opt/id_rsa &&\
              chmod 400 /opt/id_rsa &&\
              SSH="ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /opt/id_rsa root@$HOST_IP"
              $SSH '
                ufw --force reset &&\
                ufw default allow outgoing &&\
                ufw default deny incoming &&\
                ufw default deny routed &&\
                ufw allow in on eth1
              '
              for e in $(env); do
                if [[ $e =~ ^ALLOWED_IP_ ]]; then
                    $SSH "ufw allow in from $(echo $e | cut -d= -f2) to any"
                fi
              done &&\
              $SSH '
                ufw --force enable &&\
                ufw status verbose
              '
              if [ "${FORCE_RELOAD_DAEMONSET}" == "yes" ]; then
                echo "Forcing reload of cluster-admin daemonset"
                kubectl patch daemonset/cluster-admin -n cluster-admin --type merge \
                  -p '{"spec":{"template":{"metadata":{"labels":{"date":"'"$(date +%s)"'"}}}}}'
              fi
          env:
            - name: HOST_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.hostIP
          envFrom:
            - configMapRef:
                name: allowed-ips
          volumeMounts:
            - name: revoke-ips
              mountPath: /opt/secret
      serviceAccountName: revoke-ips
      containers:
        - name: pause
          image: k8s.gcr.io/pause:3.2
      volumes:
        - name: hostssh
          hostPath:
            path: /root/.ssh
        - name: revoke-ips
          secret:
            secretName: revoke-ips
